/*
   G-Machine on LMNtal
*/

{
% compiler

length_cons @@
R = length([H|L], N)
  :- Nplus1 = N + 1, ground(H)
     | R = length(L, Nplus1).

length_nil @@
R = length([], N)
  :- R = N.


/*
Program = [
    ["id", "x"] = "x",
    ["main"   ] = ("id", 3)
].
*/


Program = [
    ["k", "x", "y"     ] = "x",
    ["s", "x", "y", "z"] = (("x", "z"), ("y", "z")),
    ["id"              ] = (("s", "k"), "k"),
    ["main"            ] = ("id", 3)
].

compile(Program).


compileSC @@
    compile = [ [ Name | Vs] = Body | SCs ]
  :- ground(Vs)
     | compile = SCs, 
       m(Name, !A), 
       !A = nGlobal([compileC(Body, Vs, 0), slide(length(Vs, 1)), unwind]).

compiled @@
compile = [] :- .

compileFreeVar @@
R = compileC(Var, [], N)
  :- int(N), string(Var)
     | R = pushGlobal(Var).

compileLocalVar_lookup @@
R = compileC(Var1, [Var2|Vs], N)
  :- Var1 \== Var2, Nplus1 = N + 1
     | R = compileC(Var1, Vs, Nplus1).

compileLocalVar_resolve @@
R = compileC(Var1, [Var2|Vs], N)
  :- Var1 == Var2, ground(Vs)
     | R = push(N).

compileApp @@
H = [ compileC((E0, E1), Env, N) | T ]
  :- Nplus1 = N + 1, ground(Env)
     | H = [ compileC(E1, Env, N), compileC(E0, Env, Nplus1), mkap | T ].


compileInt @@
R = compileC(Int, [], N)
  :- int(N), int(Int)
     | R = pushInt(Int).



% initial
code = [pushGlobal("main"), unwind].
stack = [].

% G-Machine

pushGlobal @@
code = [pushGlobal(F)|Is], stack = S, m(MF, !A)
  :- F == MF
     | code = Is, stack = [!A|S], m(MF, !A).

pushInt @@
code = [pushInt(N)|Is], stack = S
  :- int(N)
     | code = Is, stack = [!A|S], !A = nNum(N).


mkap @@
code = [mkap|Is], stack = [!A1, !A2|S]
  :- code = Is, stack = [!A|S], !A = nApp(!A1, !A2).

push @@
code = [push(N)|Is], stack = S
  :- Nplus1 = N + 1
     | code = [pushing|Is], stack = [lookupStack(Nplus1)|S].

pushLookup @@
H = [lookupStack(N), A|T]
  :- N > 0, N_1 = N - 1
     | H = [A, lookupStack(N_1)|T].

pushResolve @@
code = [pushing|Is], stack = S, H = [lookupStack(0), !A|T], !A = nApp(Al, !Ar)
  :- code = Is, stack = [!Ar|S], H = [!A|T], !A = nApp(Al, !Ar).


slideN @@
code = [slide(N)|Is], stack = [!A0, !A1|S]
  :- N > 0, N_1 = N - 1
     | code = [slide(N_1)|Is], stack = [!A0|S].

slide0 @@
code = [slide(0)|Is]
:- code = Is.

unwindApp @@
code = [unwind], stack = [!A|S], !A = nApp(!A1, !A2)
  :- code = [unwind], stack = [!A1, !A|S], !A = nApp(!A1, !A2).

unwindInt @@
code = [unwind], stack = [!A|S], !A = nNum(N)
  :- int(N)
     | code = [], stack = [!A|S], !A = nNum(N).

unwindGlobal @@
code = [unwind], stack = [!A0|S], !A0 = nGlobal(Cs)
  :- ground(Cs)
     | code = Cs, stack = [!A0|S], !A = nGlobal(Cs).

}.

final @@
{code = [], stack = [!A], !A = nNum(N), $p[], @r}
  :- int(N)
     | result = N.



/*
append_cons @@
R = append([H|T], L)
  :- R = [H|append(T, L)].

append_nil @@
R = append([], L)
  :- R = L.
*/

/*
init_length @@
R = length(L)
  :- R = length(L, 0).
*/

